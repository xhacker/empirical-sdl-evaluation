\documentclass[12pt]{article}

\usepackage{inconsolata}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{graphicx,epsfig}
\usepackage[noend]{algpseudocode}
\usepackage[toc,page]{appendix}
\usepackage{float}
\newcommand{\graphWidth}{11.5cm}

% Custom style start

\usepackage{geometry}
    \newgeometry{
        top=1in,
        left=1.25in,
        bottom=0.7in,
        right=1.25in,
        includefoot
    }
\usepackage{url}

\RequirePackage{setspace}
\newcommand{\defaultspacing}{\onehalfspacing}
\newcommand{\smallspacing}{\singlespacing}

\defaultspacing

% Custom style end

\title{\textbf{An Evaluation of the Statement Deletion Mutation Operator in Real World Python Projects}}
\author{Shan Cao, Dongyuan Liu}

% ATTENTION, READER
% The filecontents thing here is where you put sources.
% Then, use, eg, \cite{GP} to cite the @misc{GP... item.
% This does mean compiling is now 3 steps IF you've added new sources:
% $ pdflatex report.tex
% This, as a side effect, generates our bib file.
% $ bibtex report
% This compiles the bib file
% $ pdflatex report.tex
% This incorporates the new bibliography into the report
% If you haven't changed sources, just use pdflatex report.tex once, it'll be fine.

\begin{document}

\maketitle
\tableofcontents

\section{Introduction}

Many open-source libraries use test coverage as a measurement of test suite quality. However, test coverage only guarantee the code is being executed when running the tests, it does not check that the tests are able to detect real faults. An extreme example is a test suite without any assertion.

To get deeper knowledge of the flaws, running test set against slightly modified versions of programs is one approach\cite{}. This technique is called \emph{mutation testing}. A quality measure, \emph{mutation adequacy score}, is used to assess. The mutants are generated from operations such as insert and delete. However, generating and testing a vast amount of mutants can be slow, therefore the efficiency of each operation should be analyzed to approximate the goal methodically.

using only delete is effective and fast ref 1 2 3

\subsection{Related Work}

The efficiency and effectiveness of only applying delete operation has been investigated in existing works.

\subsection{Our Contribution}

we evaluate on real-world Python projects

\section{Implementation Details}

\subsection{MutPy}

\emph{MutPy} is a mutation testing tool for Python projects \cite{mutpy}.

\subsection{Statement Deletion Mutation Operator}

\section{Empirical Evaluation}

\subsection{Methodology}

To collect real world Python projects for evaluation, we chose popular repositories in Python on GitHub. Because MutPy only supports projects with tests based on standard unittest module, we only choose projects using the Python unittest module. We have collected 8 Python projects in total: a, b, c, d, e, f, g, and h. These projects vary size, the smallest has xxx lines of code, the largest has yyy lines of code.

For each project we have collected, we did the steps as follows to evaluate:

\begin{enumerate}
  \item Use \emph{pytest} \cite{pytest} to run the unit tests, use \emph{pytest-cov} \cite{pytest-cov} to generate coverage report. Record time usage and test coverage.
  \item Run a full mutation testing using MutPy. Record time usage and mutation score.
  \item Run a mutation testing with only SDL operator using MutPy. Record time usage and mutation score.
\end{enumerate}

We run all the tests on a MacBook Pro with Intel i7-4850HQ, OS X 10.11.4, and Python 3.5.1.

\section{Conclusions}

\subsection{Further Work}

Based on our evaluation, we think that there are many potential future work for SDL operator, and mutation testing in general.

\subsubsection{Extend MutPy Support}

Currently MutPy only loads unit tests based on the Python standard unittest module. However, there are many popular Python projects that do not use the unittest module, including \emph{requests} \cite{requests}, \emph{virtualenv} \cite{virtualenv}, and \emph{Jinja2} \cite{jinja2}. It would be good if MutPy could support different kinds of unit tests in Python projects.

\subsubsection{Set Timeout Wisely}

A big issue for mutation testing with SDL operator is that after removing a statement, it could form an infinite loop. Currently, MutPy uses a 5s timeout to restrict the running of a test. If a test uses more than the timeout to execute, MutPy would stop the test. However, this approach is not ideal in two ways: First, the infinite loops slow down the execution of the whole test suite. Second, in some applications, e.g. a downloading tool, a passed test may take more than 5s to execute. Stopping such test is not appropriate.

To resolve this issue, we can record the running time for all the tests before running mutation testing. For each test, we set the timeout separately based on its running time. E.g., we can use 10x running time as the timeout.

\subsubsection{Run Tests Selectively}

Mutation testing is slow because it runs the whole test suite for every mutant. However, there are many cases where a test and a mutant are not relative to each other, so that that test is not possible to kill the mutant. If we can get the coverage information for every test in advance, for each mutant, we can run only the subset of the test suite that covers the mutant, which is significantly smaller than the whole test suite.

\subsubsection{Investigate the Relevancy Between Survived Mutants and Bugs}

Our evaluation shows that using only SDL operator can get the approximate mutation score. Researches on the relevancy between survived mutants and known bugs would be useful. We would like to see number of bugs per line in code covered by mutation testing, in code covered by SDL-only mutation testing, and in all code.

\subsubsection{Explore Appropriate Use Cases for Mutation Testing}

Mutation testing is slow because it has to mutate every single line of code multiple times. If we could find some use cases where the lines of code to mutate is small, the mutation testing process would be much faster.

One scenario we can think of is using mutation testing as a pre-commit hook. Before a programmer pushes code, we run mutation testing on the lines they changed. This enforces that the developer who makes the change is also responsible for adding good quality tests for it. Because number of lines is small, the testing could be done in a short amount of time. Scenarios like this are very suitable for mutation testing.

\begin{appendices}
\end{appendices}

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}
